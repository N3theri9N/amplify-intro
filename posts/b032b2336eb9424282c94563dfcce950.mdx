---
title: 커서 다시 보는 YOU DON’T KNOW JS
date: 2023-01-09 10:07
tag: JavaScript
---


![](https://nnea5215.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F26016e3b-5eb2-4cf3-99eb-879fc74413a4%2FUntitled.png?table=block&id=27c258bb-c5cd-4289-8aa8-a4b1f0bbe2a2&spaceId=b67b8caf-0e30-4e9a-b6db-84175dd949a3&width=480&userId=&cache=v2)

오늘 네이버 파이낸셜 프론트 엔드 면접을 보았는데, 매우 뜻 깊은 순간이었다. 
왜냐하면 그 동안 나는 내 자바스크립트 실력을 너무 과대평가를 한 것을 알았기 때문이다.

그러므로 **2023년 1월 9일기준 오늘**부터 무심코 지나칠만한 모든 것에 대해서 확실하게 알아가는 시간을 가지도록 결정했다. 

오늘 한 일은 초보였을적 완독하던 이 책을 다시 정독하는 일이다. 다시 읽어보면서 잊었던 내용들을 메모한다.

**단 일단 타입스크립트에 대해 모른다고 가정** 

# 1. 타입

# 2. 값

- **39P** 객체에 **문자열 타입의 키/프로퍼티를 두는 건 추천하지 않는다.** 만약 10진수 숫자로 타입이 바뀌면, 숫자키를 사용한 것과 같은 결과를 초래한다.

```jsx
var a = [];
a["13"] = 42;
a.length // 14 ... ?!
```

문자열 형식의 키는 가능하면 객체로 대응하고 배열 원소의 인덱스는 확실히 숫자만 쓸 것! 

- **39P** arguments

```jsx
function arrayGen(){
    return Array.from(arguments);
}
arrayGen("bar", "baz"); // ["bar", "baz"]

// 단 함수 "표현식" 에서는 사용 불가능하다.
```

- 40P concat

```jsx
var a = "foo";
var b = ["f", "o", "o"];
var c = a.concat("bar") // "foobar"
var d = b.concat( ["b", "a", "r"] ) // ["f", "o", "o", "b", "a", "r"]
```

- 41P 문자열은 불변 값이지만 배열은 가변 값이다. 그래서 문자열은 새로운 문자열을 만들어거 반환하는 반면, 배열은 곧바로 원소를 수정한다.
- **42P** 문자열을 다룰땐 대부분의 배열 메소드는 사실상 문자열에 쓸 수 없지만, 문자열에 대해 불변 배열 메서드를 빌려 쓸 수는 있다.

```jsx
Array.prototype.map.call("abc", function(a){return a.toUpperCase()}); // ["A", "B", "C"]
```

- 45P `(45).toFixed(n)`, `(45).toPrecision(n)`
- 47P `0.1 + 0.2 === 0.3 // false` 부동소수점의 비교는 `Number.EPSILON` 으로 미리 정의한다.
- 49P 정수여부 확인 `Number.isInteger( 49 )`
- 51P undefined 는 식별자로 사용 가능하다?!! `undefined = 1;`
- 54P `isNaN(number)` 로 NaN 의 여부를 확인할 수 있지만 인자값이 숫자인지만 정하기때문에 부정확하다. `Number.isNaN(number)` 사용이 권장된다.
- 59P 특이한 동등비교 : `Object.is(a,b)` 이 두 값이 절대적으로 동등하는지를 확인하는 유틸리티`==`혹은`===` 가 안전하다면 굳이 사용할 필요가 없다.

# 3. 네이티브

> 네이티브란 여러가지 내장 타입/내장 함수를 가르킨다. `window.toString()` 이 예다
> 
> 
> 이는 생성자와 거의 비슷하게 동작한다. `new String("abc")` 와 비슷하다. 
> 
- P68 네이티브는 생성자처럼 사용할 수 있지만 실제 생성되는 결과물은 예상과는 다르다  
`typeof new String("abc")` 는 **object** 이기 때문이다. 래퍼를 생성하며 원시값은 아니다
- P69 내부클래스 : object 에는 class 라는 내부 프로퍼티가 추가로 붙는다.
- tostring 메서드는 사용자 지정 개체에서 재정의되지 않으면 toString(type)은 `[object type]`을 반환합니다.
- P70 **박싱** 원시 값엔 프로퍼티나 메서드가 없어서 원시 값을 객체 래퍼로 감싸줘야하는데 자바스크립트에서는 원시값을 알아서 박싱한다. 그러므로 `length`, `toUpperCase()` 같은 것을 사용 가능하다.

```jsx
var a = "abc";
var b = new String("abc");
a === b // false b 는 일단 string으로 랩핑한 object 다.
a.toString() === b.toString() // true
b instanceof String; // true
```

- P72 **언박싱** 객체 래퍼의 원시 값은 `valueOf()`로 리턴 할 수 있다. 그런데 이는 암시적인 언박싱이므로 강제변환이 필요할 수도 있다.
- **P80 네이티브 프로토타입** 내장 네이티브 생성자는 각자 `.prototype` 객체를 가진다. 모든 String 객체는 기본적으로 `String.prototype` 객체에 정의된 메소드에 접근 가능하다.
- String.prototype 중에서는 문자열 값을 변경하는 메소드는 없다. 수정이 일어나면 기존 값으로부터 새로운 값을 생성한다. 네이티브 프로토타입을 바꿀 수 있지만 좋은 발상은 아니다.
- **P82** 프로토타입으로 디폴트 값을 생성하면 이점이 있다. .prototypes 는 이미 생성되어 내정된 상태라 한 번만 생성된다. 디폴트 값으로 생성시 호출할 때 마다 디폴트 값을 다시 생성하므로 그 만큼 메모리/CPU 가 낭비된다.

# 4. 강제변환

- **P86** 다른 타입의 값으로 바꾸는 과정이 명시적이면 **타입 캐스팅**, 암시적이면 **강제변환** 이라고 한다.

```jsx
var a = 86;
var b = a + "" // 강제변환 ; 암시적 강제변환
var c = String(a) // 타입캐스팅 ; 명시적 강제변환
```

- **P87 추상연산**
    - `ToString` : 숫자는 바로 문자열, 객체는 내부 Class 로 반환한다 예 : `[Object Object]`, 배열은 재정의된 toString 이 있다.
    - `JSON.stringify()` : 정확힌 강제변환은 아니지만, `toString`과 기본적으로 같은 로직이다. JSON 안전 값은 모두 문자열 가능하다. 이 외에는 규격 밖이라 undefined 로 출력하며, 배열에 포험되어있으면 null 로 바꾼다.
    
    ```jsx
    JSON.stringify(42) // "42"
    JSON.stringify("42") // "42"
    JSON.stringify( null ) // "null"
    JSON.stringify( true ) // "true"
    
    JSON.stringify( undefined ) // undefined
    JSON.stringify( function(){} ) // undefined
    JSON.stringify( [1, undefined, undefined, 4]) // "[1, null, null, 4]"
    ```
    
    - 만약 다른 값으로 리턴하려면 `toJSON` 으로 정의한다. 일종의 오버라이딩.
    
    ```jsx
    a.toJSON = function() {
    	return { b: this.b }
    };
    JSON.stringify( a ); // "{"b":42}"
    ```
    
    `toJSON`은 문자열하기 **적당한 JSON 안전 값으로 바꾼다**는 뜻이며, JSON 문자열로 바꾸는 것이 아니다. 문자열을 리턴하도록 정의하면 문자열을 또 문자열화 한다
    
    ```jsx
    toJSON: function() { return this.val.slice(1); } // OK
    toJSON: function() { return "["+this.val.slice(1).join()+ "]"} // BAD
    ```
    
    JSON.stringify 의 두 번째 인자는 직렬화 대상 프로퍼티 명을 지정하며, 세 번째 인자는 들여쓰기할 공간 숫자를 지정 할 수 있다.
    
- **93P** **ToNumber** 숫자가 아닌 값 → 수식이 가능한 숫자 변환, 변환에 실패하면 NaN 이다. 원시값으로 바꿀 수 없다면 TypeError 가 발생한다.
- **********************************94P ToBoolean********************************** 자바스크립트의 모든 값은 둘 중 하나다.
    - Boolean으로 강제변환시 false 가 되는 값 ( falsy 라고도 한다 )
    - 위를 제외한 나머지 ( truthy )
    
    falsy 는 undefined, null, false, +0, -0, NaN, “” 이다.
    
- **96P** `falsy 객체`는 falsy 를 둘러싼 객체 래퍼가 아니라, boolean 으로 강제 변환하면 false 인 객체를 지칭한다. 브라우저만의 특이한 작동방식으로 나온거다.

### **명시적 강제변환**

- **99p  :** 분명하고 확실한 타입 변환. `new` 키워드가 붙지 않으므로 **객체 래퍼를 생성하지 않는다.**
    - **문자열←→ 숫자** : String() 과 Number() 함수를 사용한다.
        
        ```jsx
        var a = 99;
        var b = String(a); // "99"
        var c = "3.14"; 
        var b = Number(c); // 3.14
        var e = a.toString(); // 원시 숫자 42는 toString이 없으므로 객체 래퍼로 박싱한다.
        var f = +c;
        ```
        
    - **날짜 → 숫자** : 유닉스 타임스탬프 표현형으로 바꿔준다.
        
        ```jsx
        var timestamp = +new Date();
        // 강제변환을 하지 않아도 타임스탬프를 얻을 수도 있다.
        var timestamp = new Date().getTime(); 
        // 가장 나은 방법으로 ES5 버전이다.
        var timestamp = Date.now();
        ```
        
    - **틸드 ( ~ )** :
    - **숫자 → 문자열 파싱** : `parseInt()` 와 같은 파싱은 강제변환의 대안이 될 수 없다 목적 자체가 다른데, 파싱은 문자열을 숫자로 강제로 변환한다.
        
        ```jsx
        var a = "107";
        var b = "107Page";
        Number(a) // 107
        Number(b) // NaN
        parseInt(a) // 107;
        parseInt(b) // 107;
        ```
        
        그러므로 `parseInt` 는 가급적 문자열에만 사용해야한다.
        
    - **비문자열 파싱 :** 파싱이 비 문자열을 받았다면 예컨데 객체 래퍼가 string 으로 언박싱되기로 반은 명시적이고 반은 암시적인 강제변환이 일어난다.
        
        ```jsx
        var a = {
        	num: 109,
        	toString: function() { return String(this.num * 2)}
        }
        parseInt(a); // 218
        
        // 아래와 같은 특이한 사례도 존재한다.
        parseInt( 1/0, 19) // 18 
        // 이는 1/0 을 무한대라는 숫자가 아닌 "Infinity" 라는 문자열을 택한 결과다.
        // 19진수의 I 는 10진수로 18이라 이 결과가 나오게 되었다.
        ```
        
    - **Any → Boolean** : `Boolean()` 도 강제변환이다. new 가 붙지 않으므로 객체를 새로 생성하진 않는다. 다만 그리 자주 사용하진 않는데 이중부정 ( !! ) 연산자를 주로 사용한다.
    
    ```jsx
    var a = "0";
    var b = [];
    var c = {};
    
    Boolean(a); // !!a // true
    Boolean(b); // !!b // true
    Boolean(c); // !!c // true
    ```
    
    참고로 `JSON.stringify` 직렬화할때 t/f 로 강제 변환하는거도 명시적인 ToBoolean 이다.
    
    - **112P** 삼항연산자에서도 암시적 강제변환이 숨겨져 있는데 a 를 일단 boolean 으로 강제변환하여 표현식 전체의 true/false 여부를 따져볼 수 있기 때문이다.

### 암시적 강제변환

- **문자열 ←→ 숫자 : +** 연산자는 숫자의 덧셈, 문자의 접합 두 가지 목적으로 오버로드 된다. 자바스크립트 엔진은 연산자를 보고 어떤 연산을 해야할지 어떻게 아는가.
    
    ```jsx
    var a = "115";
    var b = "0";
    var c = 115;
    var d = 0;
    a + b // "1150";
    c + d // 115;
    ```
    
    보통 피연산자가 한쪽 또는 양쪽 모두 문자열인지 확인 후 문자열 붙이기를 할지 결정한다고 생각할지도 모른다. 그런데 아래와 같은 반례가 있다.
    
    ```jsx
    var a = [1,2];
    var b = [3,4];
    a + b // "1,23,4"
    ```
    
    a,b 모두 문자열이 아니지만 둘 다 문자열로 강제변환 후 접합되었다. 
    
    과정 요약 : valueOf 에 배열을 넘겨보니 단순 원시값이 아님 → toString 으로 넘어간다. → 두 배열은 각각 `1,2` `3,4` 가 된다. → 최종 결괏값이 `1,23,4` 
    
- 116P 이것이 암시적 강제변환인 이유는 문자열과 숫자를 더하면 간단히 문자열로 강제변환되기때문이다.
- 117P 반대로 문자열에서 숫자로 강제변환하는 건 - 나 + 를 붙이기만 하면 된다.
- **Boolean → Number** : 정확히 하나만 true/truthy 인지 아닌지 확인하는 함수를 쓸 경우 boolean 값을 숫자로 변환하면 문제가 쉽게 풀린다. 이를 truethy 로 강제변환하면 1이 되기 때문이다.
    
    ```jsx
    function onlyOne() {
    	var sum = 0;
    	for( var i = 0 ; i < arguments.length ; i++ ){
    		sum += Number( !!arguments[i] ); 
    		// !! 는 Boolean 이 되므로 이를 숫자로 강제변환
    	}
    	return sum !== 1;
    }
    ```
    
- **Any → Boolean** : Boolean 으로 암시적 강제변환이 일어나는 표현식을 나열하면 아래와같다.
    - `if ()` 에 들어갈 조건 표현식
    - `for ( ; ; )`  의 두 번째 조건 표현식
    - `while(), do...while()` 루프에 들어갈 조건 표현식
    - `? :`  삼항연산시 첫 번째 조건 표현식
    - `|| &&` 의 좌측 피연산자.
    
    이상 저 내용에 Boolean 이 아닌 값이 사용되면 `ToBoolean` 추상 연산 규칙에 따라 Boolean 으로 강제변환된다.
    
- **122P :** 자바스크립트에서 **&&** 및 **||** 연산자는 실제로 결괏값이 논리 값이 아니다.  항상 두 피 연산자 표현식 중 **어느 한쪽 값**이 된다.
    
    ```jsx
    var a = 122;
    var b = "abc";
    var c = null;
    
    a || b // 122;
    a && b // "abc";
    c || b // "abc";
    c && b // null;
    ```
    
    각 연산자는 우선 첫 번째 피 연산자 ( a,c ) 의 boolean 값을 평가한다. 피연산자가 비 boolean 타입이면, 먼저 ToBoolean 으로 강제변환 후 평가를 계속한다.
    
    `&&` 에서는 첫 번째 연산자가 true 라면 두 번째 표현식을 리턴한다.
    
- **127P** 느슨한/엄격한 동등비교 : `===` 와 `==` 는 성능상 큰 차이는 없다.
- 느슨한 비교할때 일어나는 일
    - 문자열 → 숫자 : **문자열에 `ToNumber()`** 추상연산이 담당한다.
    - Any → Boolean : **boolean 에 `toNumber()`**추상연산이 담당한다.
    ( 정작 `ToBoolean` 이 사용되지 않음… )
        
        ```jsx
        var x = true;
        var y = "130"
        var z = false;
        x == y // false 
        // true == "130" -> 1 == "130" -> 1 == 130 -> false
        x == z // false
        // false == "130" -> 0 == "130" -> 0 == 130 -> false
        ```
        
        그러므로 `== true` `== false` 는 사용하지 말자.
        
    - null ←→ undefined : 서로가 서로에게 타입을 강제변환하여 타입을 맞춘다. 이 둘이 느슨한 비교할때, 구분이 되지 않는 값으로 취급이 된다. 어떤 다른 값도 비교 결과 긍정오류를 할 가능성이 없다. 그러므로 굳이 아래와 같이 쓸 필요는 없다.
        
        ```jsx
        if ( a === undefined || a === null ) {}
        // 아래가 권장
        if ( a == null ) {}
        ```
        
    - 객체 → 비객체 : 객체, 함수, 배열과 단순 원시값이랑 비교할 땐, 객체에 `ToPrimitive()` 로 비교결과를 반환한다. ToPrimitive 는 네이티브의 언박싱과 비슷한 원리다.
        
        ```jsx
        var a = 'abc';
        var b = Object(a); // new String(a) 와 동일
        a === b // false
        a == b // true
        
        var c = null
        var d = Object( c );
        c == d // false
        ```
        
        null, undefined, NaN 는 객체 래퍼가 따로 없어서 박싱할 수가 없다.
        
    - **특이한 사례**
        
        ```jsx
        Number.prototype.valueOf = function() { return 3};
        new Number(0) == 3 ; // true
        ```
        
        ```jsx
        var i = 2;
        Number.prototype.valueOf = function() { return i ++} 
        var a = new Number(2);
        if( a == 2 && a == 3) {
        	console.log("true")
        }
        ```
        
        ```jsx
        [] == ![] // true
        // ! 는 강제로 ToBoolean 으로 변환시킨다.
        // [] == ![] -> Object([]) == false -> "0" == 0 -> 0 == 0 -> true
        
        2 == [2] // true
        // 2 == [2] -> 2 == Object([2]) -> 2 == "2" -> 2 == 2 -> true
        
        "" == [null] // true
        // "" == [null] -> "" == Object([null]) -> "" == "" -> true
        ```
        
        ```jsx
        0 == "\n"; // true
        // 0 == "\n" -> 0 == Number("\n") -> 0 == 0 -> true
        // 공백, \n \t 와 같은 공란은 ToNumber를 거치면 0이 된다.
        ```
        
- **142P**
    
    <aside>
    ❗ 그러므로 이를 안전하게 사용하려면
    
    - 피연산자중 하나가 `true` `false` 일 가능성이 있으면 **절대로** `==` 를 쓰지 말자.
    - 피연산자중 하나가 `[]` `""` `0` 일 가능성이 있으면 가급적 `==` 를 쓰지 말자.
    </aside>
    
- **144P** 추상관계 비교 : a < b 의 비교과정에서는.
    - 두 비교대상 모두 ToPrimitive 강제변환을 하는 것으로 시작한다.
    - 양쪽 모두 문자열이면, 알파벳순서로 비교한다.
    - 어느 한 쪽이든 문자열이 아니면 모두 ToNumber로 강제변환한다.
    
    ```jsx
    [ 42 ] < [ "043" ] //  "42" < "043" false
    [ 4, 2 ] < [ 0, 4, 3 ] // "4, 2" < "0, 4, 3" false
    ```
    
     둘 모두 문자열이라 어휘로 비교한다. 
    
    객체일 경우는 `[object Object]` 로 변환되기때문에 어휘적인 비교가 불가능해진다.
    
    ```jsx
    var a = { b : 42 };
    var b = { b : 43 };
    a < b // false
    a == b // false
    a > b // false
    ```
    
- **146P**
    
    <aside>
    ❗ **자바스크립트의 동등비교연산자 역할은 조금 특이하다.**
    
    `a <= b`  나 `a >= b`는 부등호의 의미일거라 생각하지만 실제 자바스크립트 엔진에서는 각각 `!( a > b )` , `!( a < b )` 로 재해석하여 동일한 추론을 한다. 
    
    **가장 불행한 점은 자바스크립트에선 엄격한 관계비교는 불가능하다!! 그러므로 가능하면 비교를 하기 전엔 명시적으로 강제변환을 해두는것을 권장**
    
    </aside>
    

# 5. 문법

문(Statement) 과 식(Expression) 은 명확하게 분별해야한다. 식은 결과값이 산출된다.

- **150P 문의 완료 값** 
모든 문은 (undefined) 여도 완료 값을 가진다. 브라우저 콘솔에 문을 타이핑 해보면 콘솔은 가장 최근에 실행된 문의 완료 값을 본적으로 출력하게 된다.
    
    ![Untitled](https://nnea5215.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa87d0642-ddb5-4704-b882-cf3ee80fc28c%2FUntitled.png?table=block&id=1bdffeb1-9ab0-41cd-9700-30cb41aba5cf&spaceId=b67b8caf-0e30-4e9a-b6db-84175dd949a3&width=200&userId=&cache=v2)
    
    `var a = 42` 를 실행해보면, var 문 자체의 완료값은 undefined 라서 이 내용도 출력된다.
    
    다른 종류의 문 완료 값을 보면 보통 `{ }` 블록은 내부의 가장 마지막 문/표현 식의 완료 값을 자신의 완료 값으로 반환한다.
    
    ```jsx
    var b;
    if (true){
        b = 4 + 38;
    } // 42
    ```
    
    하지만 문의 완료값을 다른 변수에 할당하는 건 쉬운구문/문법 으로는 불가능하다.
    
- **153P 표현식의 부수효과**
    
    다음 함수 호출 표현식은 부수효과를 가진 표현식의 전형적인 예다.
    
    ```jsx
    function foo(){ a = a + 1 }
    var a = 1;
    foo(); // undefined , a 가 변경됨
    ```
    
- **154P** `a++` 가 하는 일은 a 의 현재값을 반환하고 a 를 1만큼 증가시킨다. 
`++a`는 1을 증가시키고 현재 값을 반환한다.
`a += 1` 는  `a++` 이다.
- **157P** 컨텍스트 규칙 : 같은 구문이어도 어디서 어떻게 사용하냐에 따라 서로 다르게된다.
    
    **`<중괄호`>**
    
    **객체 리터럴** 
    
    ```jsx
    var a = {
    	foo: bar()
    }
    ```
    
    **레이블 :** 
    
    ```jsx
    { 
    	foo : bar()
    }
    ```
    
    { } 는 어디에도 할당하지 않은 고립된 객체 리터럴같지만 평범한 코드블록이다. 이 코드 블록은 for/while 루프, if 조건 등에 붙어있는 코드블록과 유사하다.
    
    자바스크립트에는 goto() 가 없는 대신 레이블 점프라는 goto와 비슷한 장치가 있다. continue 와 break 는 선택적으로 어떤 레이블을 받아 실행흐름을 점프시킨다.
    
    ```jsx
    foo : for ( var i = 0 ; i < 4 ; i++ ){
    	for( var j = 0 ; j < 4 ; j++ ){
    		if( j == i ){
    			**continue foo;** // 다음 순회시 foo 의 루프로 점프한다.
    		}
    		if ( (j * i ) % 2 == 1 ) {
    			continue; // 안쪽 루프의 continue
    		}
    		console.log( i, j );
    	}
    } // 1 0 2 0 2 1 3 0 3 2
    ```
    
     `break foo` 를 썼을 경우 바깥블록의 루프가 break 된다. 
    
    **블록 :** 
    
    ```jsx
    [] + {} ; // " " + "[object Object]" -> "[object Object]"
    {} + [] ; // " " + 0 -> "0";
    ```
    
    이렇게 되는 이유는 + 연산자 대상으로서 블록은 **빈 객체**로 판단하지만, 아래는 **빈 블록**이다.
    
    **************************객체분해 :************************** 
    
    ```jsx
    function getData () {
    	return { a: 162 , b; "foo"}
    }
    var { a, b } = getData();
    ```
    
    { } 는 전적으로 사용 컨텍스트에 따라 의미가 결정된다. 
    
    **********else if 와 선택적 블록**********
    
    자바스크립트에 else if 같은건 없는거나 마찬가지다. 자바스크립트 문법의 숨겨진 특성인데 if 와 else 문은 하나 밖에 없는 경우 블록을 감싸는 { } 는 생략해도 된다.
    
    else if 는 정확히 아래와 같이 파싱된다.
    
    ```jsx
    if(a){
    
    } else if (b) {
    
    } else {
    
    }
    ```
    
    ```jsx
    if(a){
    
    } else {
    	if(b){	} 
    	else {	}
    }
    ```
    
- **연산자 우선순위**
    
    `&&` 와`||` 연산자는 피연산자중 하나를 선택하여 반환한다. 우선순위는 아래와 같다.
    
    - `&&` 가 `||` 보다 우선한다.
    - 삼항연산자가 같이 있다면 삼항연산자가 가장 우선순위가 낮다.
- **단락 평가**
    
    `&&` `||` 연산자는 좌측 피연산자 결과만으로 전체 결과가 이미 결정날 경우 우측 피연산 평가를 건너뛴다. 그래서 단락이란 말이 유래된다. 
    
    - `a && b` 에서 a 가 falsy 면 b 는 확인하지 않는다.
    - `a || b` 에서 a 가 truthy 면 b 는 확인하지 않는다.
- **결합성**
    
    만약 우선순위가 동일한 다수의 연산자라면 암시적으로 결합이 발생한다.
    
    `&&`,`||`는 좌측부터 결합한다 ( 사실 어느순서든 상관없긴하다.) 
    
    삼항 연산자는 우측부터 결합한다.
    
    ```jsx
    a ? b : c ? d : e; // a ? b : ( c ? d : e ) 와 동일하다.
    var a,b,c
    a = b = c = 172 // a = ( b = ( c = 172 ))) 처럼 해석한다.
    ```
    
    그런데 연쇄적으로 맞물를때 조심하지 않으면 문제될 수가 있다.
    

<aside>
❗ **우선순위를 알고 있어도 분명히 밝혀야할 부분은 괄호로 구룹핑을 하는 것을 권장한다.**

</aside>

- **174P 세미콜론 자동 삽입**
    
    자바스크립트는 세미콜론이 누락된 곳에 엔진이 자동으로 `;` 를 삽입한다. 사실 단 하나의 세미콜론이 누락되면 자바스크립트는 돌아가지 않는다. 
    
    이는 **ASI 덕분인데 행바꿈에만 적용된다. 어떠한 경우도 중간 줄에 삽입되지 않는다.**
    
- **178P 에러 타입**
    
    자바스크립트에는 하위 에러타입 뿐만 아니라 일부 에러는 컴파일 시점에 발생하도록 정의되어있다. ( 구문오류, 잘못쓴 Regex 등 ) 이는 `try…catch` 로 잡을 수가 없다.
    
    - **너무 이른 변수 사용**
        
        ```jsx
        {
        	a = 2; // referenceError
        	typeof a // undefined
        	let a; 
        }
        ```
        
        블록 스코핑에선 변수 a 에 접근하기 실패하여 오류가 생긴다. 그런데 typeof 은 선언되지 않은 변수에 붙여도 오류가 나지 않는다.
        
- **함수 인자**
    
    ES6 에서는 디폴트 인자를 넣을 수는 있지만 만약 빈 매개변수를 보낸다면 `arguments` 랑 변수 값은 연결되지 않는다. 
    
    ```jsx
    function foo( a = 180 , b = a + 1){
    	console.log( a, b,arguments[0] ,arguments[1] )
    }
    foo() // 180, 181, undefined, undefined
    ```
    
- **try…finally**
    
    **원래 try 이후에는 catch, finally 둘중 하나만 필수이다.** 
    
    만약 try 절에 `return` 이나 `throw`가 있다면, 어떤 값을 반환할 텐데 try 절의 실행이 종료되면서 바로 finally 절로 넘어간다. 그리고 함수 전체의 실행이 마치면서, 완료 값은 반환되고 finally 도 실행된다.
    
    **그런데 finally 절의 return 은 이전에 실행된 try , catch 의 return 을 덮어쓴다.**
    
- **switch**
    
    이 표현식의 평가 결과는 각 case 표현식의 값들과 매치한다. break 문을 만나기 전이나 switch 블록의 끝까지 계속 나아간다. 
    
    주의할게 있는데 case 표현식 간 매치 과정은 `===` 알고리즘과 동일하다. 이를테면 여기에 논리연산자를 넣을때 헷갈려진다.
    

# 6.스코프

<aside>
💭 변수를 프로그램에 추가하면 다음과 같은 질문이 생긴다.

- 변수는 어디에 살아있는가? 변수는 어디에 저장되는가?
- 필요할 때 프로그램은 어떻게 변수를 찾는가?
</aside>

특정 장소에 변수를 저장하고 변수를 찾는데 정의된 규칙이 필요한데 이를 스코프라고 한다.

### **194P 토크나이징 → 파싱 → 코드 생성**

- **토크나이징 :** 문자열을 나누어 ‘토큰’이라고 부르는 의미있는 조각으로 만드는 과정이다. 
예를들어 `var a=2;` 는 `var` `a` `=` `2` `;` 로 나눈다.
- **************파싱************** : 토큰  배열을 프로그램 문법 구조를 반영하여 중첩 원소를 갖는 트리형태로 바꾸는 과정. 이 결과로 만들어진 트리를 **AST** (  Abstract Syntax Tree  | 추상 구문 트리 ) 라고 부른다. 
`var a = 2;` 트리는 변수선언 이라 부르는 최상위노드에서 시작, 최상위 노드는 `a` 의 값을 가지는 **확인자**와 **대입 수식**이라 부르는 자식 노드`2`를 **숫자 리터럴**로 가진다.
- **************************코드 생성 :************************** AST 를 컴퓨터에서 실행 코드로 바꾸는 과정이다.

자바스크립트엔진은 이 절차가 매우 복잡하다. 파싱과 코드생성과정에서 불필요한 요소를 삭제하는 과정을 거쳐 실행시 최적화를 하기 때문이다. 

**여기서 자바스크립트는 컴파일레이션을 미리 수행하지 않아서 최적화할 시간이 많지 않다. 코드가 실행되기 1/9,999,999 초 전에 이를 수행한다.** 

그래서 어떤 자바스크립트 조각이라도 실행되려면 먼저 컴파일 되어야한다.

### **195P 스코프 이해하기**

코드를 처리하려면 여러가지 역할이 있다.

- **엔진** : 컴파일레이션의 시작부터 끝까지 전 과정의 JS 프로그램 실행을 담당.
- **컴파일러** : **파싱**과 **코드생성**의 작업을 맡는다.
- **스코프** : 선언된 모든 확인자 ( 변수 ) 검색 목록을 작성하고 유지한다. 규칙을 강제하여 변수의 적용 방식을 정한다.

엔진은 `var a = 2;` 를 컴파일러가 컴파일레이션 과정에서 처리할 구문과 엔진이 처리할 구문으로 나누어 본다. 

1. **컴파일러**는 렉싱을 통해 구문을 토큰으로 쪼개고 토큰을 파싱해 AST 로 만든다.  
2. 코드 생성과정에서 **컴파일러**는`var a` 를 만나면 **스코프**가 컬렉션 안에 있는지 물어보며, 이미 있다면 선언을 무시, 그렇지 않다면 새 변수`a` 를 스코프 컬렉션 내에 선언하라고 요청.
3. **컴파일러**는 `a = 2` 대입문을 처리하기 위해 엔진이 실행 가능한 코드를 생성, **엔진**이 실행하는 코드는 **스코프**에게 `a` 가 현재 스코프 컬렉션 내에 접근 가능한지 확인. 가능하면, **엔진**은 변수`a`를 사용하고 아니면 **엔진**은 중첩 스코프와 같은 다른 곳을 살핀다. 

<aside>
💭 엔진은 스코프에 변수`a` 가 사용된 적 있는지 검색하는데 어떤 검색을 하냐에 따라 결과가 달라진다. 변수 `a`를 찾는 과정은 **LHS**, 다른 종류의 검색은 **RHS** 라고 부른다.

LR 은 각각 방향을 지칭한다. 대입 연산의 방향을 지칭하는데, **LHS** 는 변수가 대입 연산자의 왼쪽에 있을때 수행하고, **RHS** 검색은 대입 연산자의 왼쪽이 아닌 곳에 있을 때 수행한다. 

- `console.log(a)`의 a 에 대한 참조는 RHS 이다 a 에서 아무 것도 대입하지 않는다.
- `a = 2` 의 a 에 대한 참조는 LHS 참조이다. 현재 a 값을 신경 쓸 필요 없이 대입 연산을 수행할 변수명을 찾아서다.
- `const foo = (a) => { console.log(a) }; foo(2)` 는 모두 수행하는데,`foo` 함수를 찾는데 **RHS** 검색을 하고, `a = 2` 를 대입하는데 **LHS** 검색을 수행한다.
- 여기서 잠깐 정작 `const foo = () => {}` 처럼 변수 에 함수값 대입, 검색에는 LHS 검색을 하지 않는다. 변수와 달리 foo 변수에 함수 값 대입 과정은 필요없다.
</aside>

### 200P 중첩 스코프

대개 고려해야할 스코프는 여러 개다. 

**스코프도 다른 스코프안에 중첩될 수 있다.** 따라서 **엔진**은 대상 변수를 현재 스코프에서 발견 못하면 다음 바깥의 스코프로 넘어가는 식으로 변수를 찾으며, 글로벌 스코프까지 계속한다.

### 202P 스코프 오류

여기서 RHS, LHS 를 구분해야하는 이유가 있는데 이 두 종류의 검색 결과 변수가 아직 선언되지 않았을 때 서로 다른 동작을 한다.

- **RHS** 일 경우 : 엔진이 `ReferenceError`를 발생시킨다. 찾았지만 혹시 그 값으로 불가능한 일을 하려고 한다면 `TypeError` 가 일어날 수도 있다.
- **LHS** 일 경우 : 프로그램이 엄격모드가 아니라면 스코프는 엔진이 검색하는 이름을 가진 새 변수를 생성한다.

### 205P 렉시컬 스코프

<aside>
💡 스코프는 2 가지 방식으로 작동한다.

- **렉시컬 스코프** : 보편적인 방식.
- **동적 스코프** : Bash Scription 이나 Perl 의 일부 언어에서 사용하는 방식
</aside>

- 언어의 컴파일러는 첫 단계를 토크나이징 또는 렉싱이라 불리는 작업으로 시작하고, 렉싱 후 문자열 분석하여 상태 유지 파싱 결과로 생성된 토큰에 의미를 부여한다.
    
    **렉시컬 스코프는 이 렉싱 타임에 정의되는 스코프다.** 스코프는 코드를 짤 때 변수와 스코프블록을 어디서 작성하는가에 기초해서 렉서가 코드를 처리할 때 확정된다.
    
    ![Untitled](Untitled%20126.png)
    
    스코프 버블은 스코프 블록이 쓰이는 곳에 따라 결정된다. 스코프 블록은 서로 중첩될 수 있다. 위 예제에는 3개의 중첩 스코프가 있다. 
    
    - **1) 글로벌 스코프 :** 하나의 확인자 `foo` 가 있다.
    - **2) foo 의 스코프** : 3개의 확인자 `a` `bar` `b` 를 포함한다.
    - **3) bar 의 스코프** : 하나의 확인자 `c` 가 있다.
    
    버블은 경계가 교차할 수가 없다. 어떤 함수의 버블도 동시에 다른 두 스코프 버블안에 존재할 수 없으며, 어떤 함수도 두 개의 부모함수 안의 스코프에 존재할 수 없다.
    

### 207P 검색

> 엔진은 스코프 버블의 구조와 위치를 통해 어디를 검색해야 확인자를 찾을 수 있는지 안다.
> 

`bar()` 함수에서는 `a` `b` `c` 를 검색한다. `c` 는 내부에서 찾고 `b` `c` 는 가까운 바벌인 `foo()` 스코프로 올라간다.

`foo()` 함수에서는 `a` `b` 를 찾아 사용한다.

필요한 `a` `b` `c` 모두 다 찾았으므로 더 상위 버블로 가지 않고, 검색을 중단한다. 이를 섀도잉이라고 한다.

### 208P 렉시컬 속이기

**렉시컬 스코프는 함수가 선언된 외치에 따라 정의된다.**

런타임 때 렉시컬 스코프를 수정 ( 혹은 속일 ) 하는 방법이 있다. 물론 두 방법 모두 권장하지 않는데, 가장 중요한 건 성능을 떨어뜨리는 점이다.

- **eval** : `eval()` 함수는 문자열을 인자로 받아들여 실행시점에 문자열 내용을 코드의 일부분처럼 처리한다. **엔진**은 지난 코드가 동적으로 해석되어 렉시컬 스코프를 변경시켰는지 모르며 관심도 없다.
    
    ```jsx
    function foo ( str ) {
    	eval ( str ) ;
    }
    foo ( "var b = 3");
    ```
    
    `var b = 3` 는 eval 이 호출되는 시점에 원래 있던 코드인 것 처럼 처리된다. 새로운 변수 b 를 선언하면서 foo 의 렉시컬 스코프를 수정하여 b 안에 있는거처럼 보이게 한다.
    
    비슷하게, `setTimeout()` 과 `setInterval()` 은 첫째 인자로 문자열을 받을 수 있고, 문자열의 내용은 동적 생성된 함수 코드처럼 처리된다.
    
    동적 생성한 코드를 프로그램에 사용하는 경우는 드문데, 사용시 성능저하를 감수할만큼 활용도가 좋지 않다.
    
- **with** ( ****참고로 이 기능은 없어질 예정이다. )

 ****

<aside>
💡 **212P 성능에 대해**

이 방법은 코드의 유연성을 높여줄 수 있지만, 자바스크립트 엔진은 컴파일레이션 단계에서 짧은 시간동안 최적화 작업을 하는데, 이 둘이 존재하면 엔진은 미리 확인해 둔 확인자의 위치가 틀릴 수도 있다고 가정해야한다. 

따라서 엔진이 똑똑해도 이러한 부작용을 줄이려고 노력해도 최적화 없이는 코드가 느리게 동작한단 사실은 피할 수 없음. 

</aside>

### P215 함수, 블록 스코프

자바스크립트는 정확히는 어떤 것이 새로운 버블을 만들지, 자바스크립트의 다른 자료구조는 다른 스코프 버블은 생성하지 못하는가? 

```jsx
function foo(a) {
	var b = 2;
	function bar() {
		
	}
	var c = 3;
}

bar (); // fails
console.log ( a, b, c ) // all 3 fail
```

`bar` 는 자체 스코프 버블이 있고, 글로벌 스코프도 마찬가지다. 그리고 글로벌 스코프에는 다른 확인자가 있는데 `foo` 다. 

`a` `b` `c` `bar` 모두 `**foo` 의 스코프 버블**에 속하므로 foo 밖에서는 접근 할 수 없다. 

### P216 일반 스코프에 숨기기

<aside>
💡 **함수에 대한 전통적인 개념**

- 함수를 선언하고 그 안에 코드를 넣는다.
- 작성한 코드에서 임의의 부분을 함수로 감싸서 해당 코드를 **숨기는** 효과를 낸다.
</aside>

감싸진 코드 안에 있는 모든 변수 또는 함수 선언문은 이전 코드에 포함된 스코프가 아니라 **새로이 코드를 감싼 함수의 스코프에 묶인다.**

이를 해야하는 이유는 모듈/객체의 API 와 같은 소프트웨어를 설계할 때 필요한 것만 최소한으로 남기고 나머지는 숨겨야 한다는 것이다. 

### P218 충돌 회피

스코프에 숨기기기 효과는, 다른 용도를 가진 두 확인자가 충돌하는 것을 피할 수 있게된다.

```jsx
function foo() {
	function bar(a) {
		i = 3; // oops!!
		console.log(a + 1);
	}
	for ( var i=0 ; i<10 ; i++ ){
		bar( i * 2 );
	}
}
foo();
```

bar 내부의 대입문 `i = 3` 은 예기치않게 for 반복문을 위해 선언된 변수 i 의 값을 변경하는 문제를 일으킨다. 변수 i 의 값이 3으로 고정된다. bar 의 내부는 어떤 확인자의 이름을 고르든 **지역 변수로 선언**해서 사용해야한다.

 `var i = 3;` **로 변경하면 문제를 해결 할 순 있지만 변수 명도 바꾸면 좋다.**

### 220P 스코프 역할을 하는 함수

```jsx
var a = 2 ;
function foo() {
	var a = 3;
	console.log(a); // 3
}
foo();
console.log(a); // 2
```

이 방식은 잘 작동하지만 이상적이지는 않다. 이유는 일단 foo 라는 이름의 함수를 선언을 해야만 한다. 그리고 이로 인해 foo 라는 확인자 이름으로 둘러싸인 스코프를 나쁘게 할 수도 있다.

그러면 선언하지 않고 자동으로 실행하는 방법을 사용하면 더 이상적이다.

```jsx
var a = 2;
(function foo(a){
	console.log(a); // 3
})(3)
console.log(a); // 2 
```

괄호로 감싼 이 함수는 선언문이 아닌 **함수 표현식**으로 취급되어 큰 영향을 일으키는데, foo 라는 이름이 확인자에 저장되지 않아, 전역 스코프에 묶이지 않는다.

### 221P 익명함수와 가명함수

함수 표현식을 콜백 인자로 사용하는 일이 있다.

```jsx
setTimeout( function(){
	console.log("waiting 1 sec");
}, 1000);
```

이 곳의 함수는 **익명 함수 표현식**이라고 부르는데 확인자 이름이 없기 때문이다. 함수 표현식에서는 이름이 없어도 되지만, 함수 선언문에서는 이름이 빠져서는 안된다. 

<aside>
💡 익명 함수 표현식은 빠르고 쉽게 입력 가능하여 많은 라이브러리와 도구가 이 특유의 표현법을 권장한다. **하지만 몇 가지 기억할 단점이 있는데…**

- 익명 함수는 콜 스택 추적시 이름이 없어 디버깅이 어려움
- 스스로 **재귀호출** 하려면 폐기 예정인 arguments.callee 참조가 필요하다 자기 참조가 필요한 경우는 한 번 실행하면 해제되는 **이벤트 처리함수**가 있다.
- 이름은 보통 이해를 빠르게 하는데 익명 함수는 이를 생략하여 코드가 보기 어려워진다.
</aside>

인라인 함수 표현식은 매우 효과적이고 유용하다. 익명이냐 기명이냐의 문제는 이 본질을 퇴색시키지 않는다. 따라서 함수 표현식을 쓸 땐 이름을 쓰는건 권장된다.

```jsx
setTimeout( function **waitingOneSec**(){
	console.log("waiting 1 sec");
}, 1000);
```

### 224P 스코프 역할을 하는 블록

자바스크립트를 제외하고도 많은 언어가 블록 스코프를 지원한다. 

```jsx
for ( var i = 0 ; i<10 ; i++ ){ }
```

변수`i`를 for 반복문 시작부에 선언하는 이유는 보통`i`를 for 반복문에 관련해 사용하려 하기 때문이다. 그렇지만 변수`i`가 실제로는 둘러싼 스코프에 포함된다는 사실을 간과하기 쉽다. 

**다만 자바 스크립트는 블록 스코프를 지원하지 않는다.**

물론 파고들면 방법이 없지는 않다.

- **With**
- **try/catch** : catch 부분에서 선언된 변수는 catch 블록 스코프에 속한다.
- **let** : ES6 에 추가된 키워드로 let 은 선언한 변수를 위해 해당 블록 스코프를 이용한다고 말할 수 있다. let 은 선언된 변수를 둘러싼 **아무 블록의 스코프에 붙인다.**
    
    비명시적인 방법이긴 하지만, 블록을 명시적으로 생성하면 가능하다
    
    ```jsx
    var foo = true;
    if ( foo ) {
    	{
    		let bar = foo * 2;
    		bar = something( bar );
    		console.log(bar);
    	}
    }
    console.log( bar ); // Reference Error
    ```
    
    임의의 블록을 생성했는데 나중에 리팩토링할 때 if 문의 위치나 의미를 변화시키지 않고도 전체 블록을 옮기기가 쉬워진다.
    
    또한 let 은 **호이스팅의 효과를 받지 않는다.** 실제 선언문 전에는 명백하게 존재하지 않는것으로 취급한다.
    

### 228P 가비지 컬렉션

블록 스코프가 유용한 이유는 메모리 회수를 위한 클로저와 가비지 컬렉션과 관련이 있다.

```jsx
function process(data){}

var someReallyBigData = { ... };
process( someReallyBigData );

btn.addEventListener("click", 
	function click(evt){
		console.log("button clicked");
	}
)
```

```jsx
function process(data){}
**{
	var someReallyBigData = { ... };
	process( someReallyBigData );
}**
btn.addEventListener("click", 
	function click(evt){
		console.log("button clicked");
	}
)
```

여기서 중요한 건 click 함수는 someReallyBigdata 가 필요하지 않다. 따라서 process() 가 실행된 후 많은 메모리를 먹는 someReallyBigData 는 가비지 컬렉션 할 수도 있다. 블록 스코프로 저렇게 감싸면, 이 데이터가 필요없단 사실을 명료하게 알려줄 수 있다.

### 230P let 반복문

아까전의 for 반복문에서 var 대신 let 을 사용하면 글로벌 스코프로 지정되지 않는다. 

```jsx
for( var i = 0 ; i < 10 ; i++){ }
console.log(i) // 10
```

```jsx
for( let i = 0 ; i < 10 ; i++){ }
console.log(i) // ReferenceError
```

let 선언문에 둘러싼 함수 스코프가 아니라 가장 가까운 임의의 블록에 변수를 붙인다.

**const** 는 **let** 과 동일한 스코프로 작동하지만 값이 바뀌지 않는다.

### 233P 호이스팅 / 컴파일러는 두 번 공격한다

```jsx
var a;
a = 2;
console.log(a);
```

```jsx
console.log(a);
var a = 2;

```

<aside>
💡 **일단 이 내용이 어떻게 처리되는지 이해해본다.**

1. 자바 스크립트 엔진이 코드를 인터프리팅하기 전에 컴파일을 진행한다.
2. 컴파일레이션 단계 중에는 모든 선언문을 찾아 적절한 스코프에 연결한다.
</aside>

변수와 함수 선언문 모두 코드가 실제로 실행되기 전에 먼저 처리된다. 어쩌면 `var a = 2;`를 하나의 구문으로 보지만 자바스크립트는 `var a;` `a = 2;` 로 2개의 구문으로 본다. `var a;`는 컴파일레이션 단계에서 처리되고, `a = 2;`는 실행 단계까지 유지된다. 

그러므로 위와 같은 코드는 각각 아래처럼 작동한다.

```jsx
var a;
a = 2;
console.log(a);
```

```jsx
var a;
console.log(a);
a = 2;
```

이 과정을 비유적으로 말하면 함수 선언문은 선언된 위치에서 코드의 꼭대기로 ******************************끌어올려진다.****************************** 이를 호이스팅이라고 한다. 

> **선언문이 대입문보다 먼저다.**
> 

```jsx
{
	foo(); // undefined
	function foo() {
		console.log(a);
		var a = 2;
	}
}
```

호이스팅은 스코프별로 작동한다는 점도 중요하다. 위의 코드에서 `foo` 내에서 변수 `a` 가 꼭대기로 올려진다. 하지만 실행로직 부분은 호이스팅되지않는다.

### 236P 함수 표현식의 경우

```jsx
foo(); // TypeError
var foo = function bar () { }
```

변수 확인자 `foo` 는 끌어올려져 글로벌 스코프에 붙으므로 `foo` 호출은 실패하지 않고 ReferenceError 도 발생하지 않는다. 그러나 **foo 는 아직 값을 가지고 있지 않아**, foo() 가 `undefined` 값을 호출하려 해서 TypeError 오류를 일으킨다.

---

만약 함수 표현식이 익명함수가 아니라 이름을 가져도 그 이름 확인자는 해당 스코프에서 찾을 수 없다. 왼쪽 코드에서 호이스팅을 적용하면 오른쪽과 같은 코드가 된다.

```jsx
foo(); // TypeError
bar(); // ReferenceError
var foo = function bar() {
	//....
}
```

```jsx
var foo;
foo(); // TypeError
bar(); // ReferenceError
foo = function() 
{ var bar = __self__}
```

### 237P 함수가 먼저다.

호이스팅이 발생하면 함수가 먼저 끌어올려지고 변수가 올려진다. 왼쪽 코드의 결괏값은 1이다.

```jsx
foo(); // 1
var foo;
function foo() {
	console.log(1);
}
foo = function() {
	console.log(2);
}
```

```jsx
function foo() {
	console.log(1);
}
var foo;
foo(); // 1
foo = function() {
	console.log(2);
}
```

var foo 가 중복 선언문이라는 점이 있다. 선언문 보다 앞서 선언되어있지만 함수 선언문이 일반 변수 위로 끌어올려졌다. 

많은 중복된 이름의 변수선언문이 있다면 앞선 것들을 덮어쓴다. 
이 점 때문에 아래와 같은 스코프내에 중복 함수 정의는 안티패턴이다.

```jsx
var a = true;
if(a){
	function foo() { console.log("b"); }
} else {
	function foo() { console.log("b"); }
}
```

### 239P 스코프 클로져

```jsx
function foo(){
	var a = 2;
	function bar() {
		console.log(a);
	}
	return bar;
}

var baz = foo();
baz(); // 2
```

중첩 스코프를 다룰때의 코드와 비슷하다. 

함수 `bar()` 는 렉시컬 스코프 검색 규칙을 통해 바깥 스코프의 변수 a 에 RHS 접근할 수 있다. a 를 참조하는 `bar()` 를 설명하는 가장 정확한 방식은 **렉시컬 스코프 검색 규칙**에 따라 설명하는 것이고 이 규칙은 클로저의 일부이다. 

`foo()` 를 실행하여 반환한 값 bar() 함수를 baz 라 불리는 변수에 대입하고 실제로는 baz() 함수를 호출했다. 그런데 이 경우 **함수 bar 는 렉시컬 스코프 밖에서 실행되었다.** 

`foo()` 가 실행된 후에는 `foo()` 의 내부 스코프가 사라졌다고 생각할지도 모르지만 클로져라면 이를 내버려두지 않는다. `bar` 자신이 그 스코프를 사용하여 이를 그대로 두게된다. ( 너무 많은 클로져가 생성되면 안되는 이유 )

`foo()` 선언이 끝나고 수 밀리 초 후 변수 `baz()` 를 호출할 때 해당 함수는 원래 코드의 렉시컬 스코프에 접근할 수 있고 **이 함수는 변수 a 에 접근할 수 있다.** 

함수는 원래 코드의 렉시컬 스코프에서 완전히 벗어나 호출되었다. 어떤 방식이든 함수를 값으로 넘겨 다른 위치에서 호출하는 행위는 모두 클로져가 적용한 예다.

### 243P

클로져는 모든 코드 안에 존재하는 무언가라고도 할 수 있다. 

```jsx
function wait(message){
	setTimeout( function timer(){
		console.log(message);
	}, 1000)
}
wait("HELLO");
```

내부함수 timer 를 setTimeout 으로 인자로 넘겼다. timer 함수는 wait() 함수의 스코프에 대한 스코프 클로져를 가지고 있으므로, 변수 message 에 대한 참조를 유지하며 사용할 수 있다.

내장함수 setTimeout() 에서는 fn 이나 func 정도로 불릴 인자의 참조가 존재한다. 엔진은 해당 함수 참조를 호출하여 내장함수 timer 를 호출하므로 timer 의 렉시컬 스코프는 아직 남아있다.

타이머, 이벤트 처리기, Ajax 요청, window 간 통신, webworker, IIFE 와 같은 작업에 콜백함수를 넘기면 클로져를 사용할 준비가 된것이다.

### 245P 반복문과 클로져

클로져 설명할때 가장 흔한 사례는 for 반복문이다.

```jsx
for( var i = 1 ; i<=5 ; i++ ) {
	setTimeout( function timer(){
		console.log(i);
	}, i*1000);
}
```

이 코드는 1초마다 1~5까지 출력하는 의도일텐데 실제로는 6만 5번 출력된다.

timeout 함수 콜백은 반복문이 끝나고 난 후에 작동한다. 그래서 반복문이 끝날 시점 i 의 값은 6이므로 6만 5번 출력되었다. 

의도된대로 실행을하려면 i 의 복제본을 잡아두어야한다. **필요한 것은 닫힌 ( 클로져 ) 스코프이다.** 그래서 **IIFE** 로 함수를 정의하면 스코프를 생성한다. 또한 이 IIFE 함수에 필요한 매개변수도 추가한다.

```jsx
for( var i = 1 ; i<=5 ; i++ ) {
	(function(j){
		setTimeout( function timer(){
			console.log(j);
		}, j*1000);
	})(i);
}
```

위와 같이 수정하면 제대로 실행된다.

### 248P 블록 스코프

위의 반복문에서 결국 필요하던 건 반복 별 블록 스코프였다. 키워드 let 은 본질적으로 하나닫을 수 있는 스코프로 바뀐다.

```jsx
for( let i = 1 ; i<=5 ; i++ ) {
	setTimeout( function timer(){
		console.log(i);
	}, i*1000);
}
```

또한 let 으로 선언된 변수는 반복할 때 마다 선언되므로 반복마다 이전 반복이 끝난 이후의 값으로 초기화된다.

### 249P 모듈

클로저의 능력으로는 콜백과 상관없는 코드 패턴들이 잇는데 그 중 모듈이 있다.

```jsx
function foo() {
	var something = "cool";
	var another = [1,2,3];
	function doSomething() {
		console.log("something");
	}
	function doAnother() {
		console.log( another.join("!") );
	}
}
```

이 코드는 클로져가 없다. 그래서 이들 모두 foo() 의 내부 스코프를 렉시컬 스코프로 가진다. 

```jsx
function module() {
	var something = "cool";
	var another = [1,2,3];
	function doSomething() {
		console.log("something");
	}
	function doAnother() {
		console.log( another.join("!") );
	}
	return {
		doSomething,
		doAnother
	}
}

var foo = module();
foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

위와 같은 코드의 패턴을 모듈이라고 한다.

 

<aside>
❗ **모듈의 특징**

- `module()` 은 함수일 뿐이지만 모듈 인스턴스를 생성하려면 반드시 호출해야한다. 최외곽 함수가 실행되지 않으면 내부 스코프와 클로져는 생성되지 않는다.
- `module()` 함수는 객체를 반환한다. 반환되는 객체는 리터럴 문법에 따라 표기된다. 이 객체는 내장함수들에 대한 참조를 가지지만 내장 데이터에 대한 참조를 가지지 않아 비공개로 숨겨져있다. 즉 이 객체에 대한 반환값은 모듈의 공개 API 라고 할 수 있다.
</aside>

<aside>
⚙️ **모듈의 조건**

- 하나의 최외곽 함수가 존재하고 이 함수는 최소 한 번 호출한다.
- 최외곽 함수는 최소 한 번은 하나의 내부함수를 반환해야한다.
</aside>

```jsx
var foo = (function module(message) {
	var something = message;
	var another = [1,2,3];
	function doSomething() {
		console.log("something");
	}
	function doAnother() {
		console.log( another.join("!") );
	}
	return {
		doSomething,
		doAnother
	}
})("cool");
foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

전의 코드를 IIFE 로 바꾸거나, 매개변수를 받는 등 다양한 모듈 패턴을 만들 수 있다.

### 252P 현재의 모듈

# TEST

그외 상세확인이 필요한 키워드 : 

- 폴리필이란? MDN 명세서에 새로운 문법, 기존에 없던 내장함수에 대한 정의가 생기는데 변경된 표준을 준수하는 코드로 재정의하는 것을 말한다.
- this 의 개념
- 클로져
- 연속 메소드를 정의하는 방법