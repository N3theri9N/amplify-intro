---
title: JavaScript Memory 관리 
date: 2023-03-23
tag: JavaScript
---

# JavaScript Memory 관리

생성 일시: 2023년 3월 23일 오후 5:39

자바스크립트는 객체가 생성되었을 때 자동으로 메모리를 할당하고 더 이상 필요 없으면 자동으로 해제한다. ( Garbage Collection ) 이러한 관리는 잠재적인 혼란을 일으킬 수 있는데, 개발자가 메모리에 관해 고민할 필요가 없단 인상을 심어줄 수도 있다.

# 메모리 주기

<aside>
📌 메모리 주기는 어떤 언어든 동일하다.

- 필요할 때 할당한다.
- 할당된 메모리를 사용한다.
- 더 이상 필요하지 않으면 해제한다.
</aside>

## 필요할 때

자바스크립트는 값을 선언할 때와 함수 호출의 결과, 메소드가 새로운 값이나 오브젝트를 생성시 자동으로 메모리를 할당한다. 

```jsx
var n = 123; // 정수를 담기 위한 메모리 할당
var s = 'azerty'; // 문자열을 담기 위한 메모리 할당

var o = {
  a: 1,
  b: null
}; // 오브젝트와 그 오브젝트에 포함된 값들을 담기 위한 메모리 할당

// (오브젝트처럼) 배열과 배열에 담긴 값들을 위한 메모리 할당
var a = [1, null, 'abra'];

function f(a) {
  return a + 2;
} // 함수를 위한 할당(함수는 호출 가능한 오브젝트)

// 함수식 또한 오브젝트를 담기 위한 메모리를 할당합니다.
someElement.addEventListener('click', function(){
  someElement.style.backgroundColor = 'blue';
}, false);

var d = new Date(); // Date 개체를 위해 메모리를 할당
var e = document.createElement('div'); // DOM 엘리먼트를 위해 메모리를 할당

var s = 'azerty';
var s2 = s.substr(0, 3); // s2는 새로운 문자열
// 자바스크립트에서 문자열은 immutable 값이기 때문에,
// 메모리를 새로 할당하지 않고 단순히 [0, 3] 이라는 범위만 저장합니다.

var a = ['ouais ouais', 'nan nan'];
var a2 = ['generation', 'nan nan'];
var a3 = a.concat(a2);
// a 와 a2 를 이어붙여, 4개의 원소를 가진 새로운 배열
```

## 사용할 때

값을 사용할 때 기본적으로 할당된 메모리를 읽고 쓰는 것을 의미한다. 변수나 객체 속성의 값을 읽고 쓰거나 함수 호출 시 함수에 인수를 전달하여 수행할 수 있다.

## 해제하기

이 단계에서 문제가 생기는데 종종 **할당된 메모리가 필요없을 때를 알아내기가 어렵기 때문**이다. 자바스크립트와 같은 하이레벨 언어들은 가비지 컬렉션이라는 자동 메모리 관리 방법을 사용한다. 단 한계점이 있는데 어떤 메모리가 여전히 필요한지 아닌지를 판단하기를 어려워한다.

가비지 콜렉션 알고리즘의 핵심 개념은 **참조** 이다. A 라는 메모리를 통해 B 라는 메모리에 접근 할 수 있다면 B는 A 에 참조된다고 한다. 예를들어 자바스크립트의 객체는 prototype 을 암시적으로 참조하고 프로퍼티값을 통해 명시적으로 참조한다.

### Reference-counting 알고리즘

가장 흔한 예는 참조-세기 알고리즘으로 **더 이상 필요없는 오브젝트는 곧** **어떤 다른 객체도 참조하지 않는 객체** 라고 정의한다. 

```jsx
var x = {
  a: {
    b: 2
  }
};
// 2개의 오브젝트가 생성되었습니다. 하나의 오브젝트는 다른 오브젝트의 속성으로 참조됩니다.
// 나머지 하나는 'x' 변수에 할당되었습니다.
// 명백하게 가비지 콜렉션 수행될 메모리는 하나도 없습니다.

var y = x;      // 'y' 변수는 위의 오브젝트를 참조하는 두 번째 변수입니다.

x = 1;          // 이제 'y' 변수가 위의 오브젝트를 참조하는 유일한 변수가 되었습니다.

var z = y.a;    // 위의 오브젝트의 'a' 속성을 참조했습니다.
                // 이제 'y.a'는 두 개의 참조를 가집니다.
                // 'y'가 속성으로 참조하고 'z'라는 변수가 참조합니다.

y = "mozilla";  // 이제 맨 처음 'y' 변수가 참조했던 오브젝트를 참조하는 오브젝트는 없습니다.
                // (역자: 참조하는 유일한 변수였던 y에 다른 값을 대입했습니다)
                // 이제 오브젝트에 가비지 콜렉션이 수행될 수 있을까요?
                // 아닙니다. 오브젝트의 'a' 속성이 여전히 'z' 변수에 의해 참조되므로
                // 메모리를 해제할 수 없습니다.

z = null;       // 'z' 변수에 다른 값을 할당했습니다.
                // 이제 맨 처음 'x' 변수가 참조했던 오브젝트를 참조하는
                // 다른 변수는 없으므로 가비지 콜렉션이 수행됩니다.
```

한계점이 존재하는데, 두 객체가 서로 참조하는 속성으로 생성되어 순환 구조를 생성할 경우 사용이 끝나면 그 시점에는 두 객체는 불필요하므로 회수되어야하지만 서로를 참조하고 있어서 가비지콜렉션의 대상으로 표시되지 않는다.

```jsx
function f() {
  var x = {};
  var y = {};
  x.a = y;         // x는 y를 참조합니다.
  y.a = x;         // y는 x를 참조합니다.

  return "azerty";
}

f();
```

### Mark-and-sweep

이 알고리즘은 **닿을 수 없는 오브젝트는 필요없다**고 정의한다. roots 로 부터 시작하여 이를 참조하는 객체들 중 닿을 수 없는 것을 가비지 컬렉팅 한다. 모던 자바스크립트의 가비지 컬렉션은 이 알고리즘을 사용한다. 

이하의 단계를 거쳐 수행한다.

- 루트 정보를 수집하고 **mark**한다.
- 루트가 참조하는 모든 객체를 반복하고 이를 **mark**한다.
- **mark**된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 **mark**한다. 한 번 방문한 객체는 전부 **mark**하기 때문에 같은 객체를 다시 방문하진 않는다.
- 루트에서 도달 가능한 모든 객체를 방문할 때 까지 위 과정을 반복한다.
- **mark**되지 않은 모든 객체를 메모리에서 삭제한다.

<aside>
📌 **어떤 메모리를 언제 해제할지 수동으로 결정**하는 것이 편리할 때가 있다. 그런데 이 방법으로 해제하려면, 객체 메모리에 도달할 수 있도록 명시하는 기능이 있어야만 하므로 좋지 않다. 그러므로 현재 명시적/프로그래밍 방식으로 가비지컬렉션을 작동할 수 없다.

</aside>

# 삭제되지 않는 것

**도달 가능한 값**들은 메모리에 삭제되지 않는다. 이러한 값의 예시는

- 현재 함수의 지역 변수와 매개 변수
- 중첩 함수의 체인이 있는 함수에서 사용되는 변수와 매개변수
- 전역 변수
- 루트가 참조하는 값이나 체이닝으로 루트에서 참조 가능한 값

상세 레퍼런스 : [https://ko.javascript.info/garbage-collection](https://ko.javascript.info/garbage-collection)